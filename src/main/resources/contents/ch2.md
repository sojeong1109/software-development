## ch2
1. 챕터의 목표
2. 챕터 과제 (요구사항)
3. KISS 원칙이란, 장/단점
4. 코드 유지보수 고려할 사항
5. 단일 책임 원칙 SRP

### 목표
1. 좋은 소프트웨어 개발의 기반은 무엇인가?
2. 단일 책임 원칙 SRP 학습 (Single responsibility principle)
   1. 유지보수를 쉽게 하고, 버그 발생 범위 축소
3. 응집도와 결합도의 특징
   1. 응집도 : 클래스, 패키지, 메서드 등의 관련도
   2. 결합도 : 기능이 다른 클래스에 얼마나 의존하고 있는지.

### 요약
1. 갓 클래스와 코드 중복은 코드를 추론하고 유지보수하기 어렵게 만드는 요인임.
2. 단일 책임 원칙(SRP)는 관리하고 유지보수하기 쉬운 코드를 구현하는데 도움을 준다.
3. 응집도는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킴.
4. 결합도는 클래스가 달느 코드 부분에 얼마나 의존하고 있는지를 가리킴.
5. 높은 응집도와 낮은 결합도는 유지보수가 가능한 코드가 가져야 할 특성이자 목표임.
6. 자동화된 테스트 스위트는 소프트웨어가 올바로 동작하며, 코드를 수정해도 잘 동작할 것임을 확신할 수 있고, 프로그램 이해에 도움을 줌.

### 요구사항 : 입출금 내역 분석기
1. 은행 입출금 내역의 총 수입과 총 지출은 각각 얼마인가? 결과가 양수인가 음수인가?
2. 특정 달엔 몇건의 입풀금 내역이 발생했는가?
3. 지출이 가장 높은 상위 10건은 무엇인가?
4. 돈을 가장 많이 소비하는 항목은 무엇인가?

### KISS (Keep it short and simple) 원칙
* 한개 파일에 몽땅 다 만듦.
* 예제로 BankTransactionAnalyzerSimple1 파일 생성
* 장점
  * 코드가 간결 함 (여러 파일을 사용 할 필요가 없음)
* 단점
  * 한 개의 거대한 갓 클래스(god class) 때문에 이해 어려움
    * 갓 클래스(god class)
      * 너무 거대해서 목적이 무엇인지 이해 어려움
      * 기존 코드의 로직을 갱신해야 하는 경우 찾아서 바꾸기 어려움
      * 이런 어려움들을 **갓 클래스 안티 패턴** 이라고 부름.
      * 해결하기 위해서 유지보수 할 수 있는 코드를 구현하는데 도움을 주는 **단일 책임 원칙**을 사용.
  * 코드 중복(code duplication) 때문에 코드가 불안정하고 변화에 쉽게 망가짐
    
### 코드 유지보수 고려사항
1. 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 함.
2. 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 함.
3. 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거 할 수 있어야 함.
4. 캡슐화(encapsulation)가 잘 되어야 함. 
   1. 즉, 코드 사용자에게는 세부 구현 내용이 감춰져 있으므로 사용자가 쉽게 코드를 이해하고, 기능을 바꿀 수 있어야 함.
5. 중복 배체 DRY (don't repeat yourself). 
   1. 반복을 제거하면 로직을 바꿔도 한곳만 바꿔도 다 적용되니까 여러곳의 코드를 바꿔야 할 필요성이 없어짐.

### 단일 책임 원칙
* 쉽게 관리하고 유지보수하는 코드를 구현하는데 도움을 주는 포괄적인 소프트웨어 개발 지침이다.
* SRP 는 일반적으로 클래스와 메서드에 적용하며, 한 가지 특정 동작, 개념, 카테고리와 관련 있다.
* SRP 적용시, 코드가 바뀌어야 하는 이유가 한 가지로 제한되므로 더 튼튼한 코드를 만들 수 있다.
* 코드가 바뀌는 이유가 한 가지가 아니라면, 여러 장소에서 코드 변경이 발생하므로 코드 유지보수가 어렵다.
* BankTransactionAnalyzerSimple 파일에 있는걸 기능 단위로 분리하여 SRP 를 적용한다.
  1. 입력 읽기 (BankStatementCSVParser > parseFromCSV)
  2. 주어진 형식의 입력 파싱 (BankStatementCSVParser > parseLinesFromCSV)
  3. 결과 처리
  4. 결과 요약 리포트

### 응집도
* 코드 품질과 관련된 특성이며, 유지보수성을 결정하는 중요한 개념
* 클래스나 메서드 들이 서로 어떻게 관련되어 있는지를 가르킴
* 소프트웨어 복잡성을 유추하는데 도움을 준다
* 목표 : 높은 응집도, 쉽게 코드를 찾고, 이해하고, 사용할 수 있도록
* BankStatementCSVParser1 파일이 응집도가 높다고 볼 수 있음
* 보통 응집도의 개념은 클래스(클래스 수준 응집도)에 적용하지만, 이를 메서드에도 적용 가능 함.
* ex. BankStatementAnalyzer > calculateTotalAmount, selectInMonth 계산하는 메소드를 별도의 계산하는 BankStatementProcessor 클래스로 추출하여 응집도를 높인다.

### 클래스 수준 응집도 (표 : 책 p.38)
* 실무에서는 일반적으로 아래와 같은 여섯가지 방법으로 그룹화 함.
  * 기능
  * 정보
  * 유틸리티
  * 논리
  * 순차
  * 시간

#### 기능
* 기능상 함께하는 메서드 들을 그룹화 하여 클래스 생성 (서로 호출 하는 경우)
* ex. BankStatementCSVParser1 > parseLinesFromCSV, parseFromCSV
* 다만, 기능 응집은 한개의 메서드를 갖는 클래스를 너무 과도하게 만들지 않도록 주의.

#### 정보
* 같은 데이터나 도메인객체를 처리하는 메서드를 그룹화하는 방법도 있음.
* ex. crud 하는 연산을 처리 하는 클래스 생성.
* DAO

#### 유틸리티 (utility class)
* 관련 없는 메서드를 한 클래스로 포함 하는 경우
* 낮은 응집도로 사용 자제. 클래스의 전체 기능을 통칭하기 어려움.

#### 논리
* 같은 논리를 가지고 있는 메서드들의 집합
* ex. BankStatementCSVParser1 : CSV, JSON, XML 자료를 파싱하는 코드들 모아놓은 곳.
* 각 메소드 서로 연관이 없고, SPR을 위배하여 결과적으로 추천하지 ???? 왜지....(결합도 에서 설명)

#### 순차
* 입출력이 순차적으로 흐르는것
* 여러 동작이 어떻게 함께 수행되는지 쉽게 이해 됨.
* 그러나, 한클래스에 바꿔야 할게 많아서 SRP를 위배하여 비추

#### 시간
* 시간과 관련된 연산
* 어떤 작업 시작하기전 뒤에 초기화 뒷정리 담당하는 메서드를 모아놓은 클래스

### 결합도 (coupling 폴더 내)
* 한 기능이 다른 클래스에 얼마나 의존하고 있는지
* 많은 클래스를 참조할 경우 기능을 변경할때 유연성이 떨어짐.
* 인터페이스와 구현이 서로 결합하지 않아야 함.
* 목표 : 결합도를 낮춰야 함. (= 너무 세부구현에 의존하지 않아야 함.)
* ex.BankStatementAnalyzer 는 BankStatementCSVParser1에 의존함.
1. 어떻게 사용하는지 정의하는 인터페이스를 만들어야 함. (BankStatementParser)
2. 상속하는 구현체 만들기 (BankStatementCSVParser) 
3. cohesion에 있는 BankStatementAnalyzer와 coupling > BankStatementAnalyzer 비교.
4. coupling BankStatementAnalyzer 의 파일을 보녕 중간 interface BankStatementParse r를 사용하여 결합도를 낮춤.

### 테스트
* 자바 테스트 프레임워크 중 제이유닛 사용.
* 초반보다는 나중에 코드의 기능이 많아지거나 유지보수에 들어가면서 테스트의 필요성이 높아짐.
* 자동화된 테스트에서는 테스트가 포함된 스위트(suite)가 자동으로 실행 됨.
* 장점
  * 확신 : 고객의 요구 사항에 맞게 테스트, 테스트 결과가 증거가 됨.
  * 변화에 튼튼함 유지 : 수정시 휴먼에러 방지
  * 프로그램 이해도 : 테스트를 하며 다양한 컴포넌트의 디펜던시와 상호작용 빠르게 파악 가능.

#### 테스트 파일 생성
* 유닛 테스트 클래스는 "Test"라는 접미어를 붙이는 것이 관습
* 파일 위치 : src/test/java
* 클래스는 shouldParseOneCorrectLine() 이라는 하나의 메서드 선언
  * 쉽게 알 수 있도록 서술적인 이름이 좋음
* 제이유닛의 어노테이션인 @Test를 메서드에 붙여주기 (<- 유닛테스트의 샐행 대상임을 지정
* 비공개 헬퍼 메서드를 테스트 클래스에 선언 할 수 있지만, 테스트 러너는 이런 메서드를 실행하지 않음. <????
* Assert 구문 (정적 메소드 제공) : https://scshim.tistory.com/177
* ex. BankStatementCSVParserTest
* 테스트 설정의 세 단계 패턴 : Given-When-Then 공식 (이 공식을 써야 테스트가 무엇을 수행하는지 쉽게 이해 가능.)
1. 테스트 콘텍스트 설정 (예제에서는 파싱할 행을 설정)
* 2. 동작을 실행 (예제에서는 입력행을 파싱한다)
* 4. 예상된 결과 를 어서션으로 지정 (예제에서는 날짜, 금액 설명이 제대로 파싱 되었는지 확인)

#### 코드 커버리지
* 테스트 집합이 소프트웨어의 소스코드를 얼마나 테스트 했는가를 가리키는 척도.
* 커버리지가 높을 수록 예상하지 못한 버그 확률이 낮아짐.
* 목표는 모통 70~90%
* 자바에서는 자코코(JaCoCo), 에마(Emma), 코베르투라(Cobertura) 같은 코드 커ㅓ리지 도구를 많이 사용함.
* 얼마나 많은 구분의 코드를 커버했는지를 의미하는 구분 커버리지(line coverage)에 대해 얘기함. 
* 이 기법에는 분기분을 한 구분으로 취급해버리는 치병적인 약점이 있음.
* 분기문에서는 여러개의 경로가 있기 때문
* 하여, 구문 커버리지보다는 각 분기문을 확인하는 분기 커버리지(branch coverage)를 사용하는게 좋음.

### 진행
1. KISS 원칙으로 한 파일로 구성
2. 기능별로 목록 정리
3. 재사용 할 수 있는 부분은 캡슐화 
   1. 파싱전용클래스를 생성하여, 캡슐화된 기능을 재사용해 구현한다.
   2. DTO 를 생성하여 다른 코드가 특정 데이터 형식에 의존하지 않게 됨.

#### NOTE
* DRY 원칙 (Do not Repeat Yourself) : 반복하지 마라
  * 소스 코드에서 동일한 코드가 반복이 된다는 것은 잠재적인 버그의 위협을 증가시킴.
* 도메인(domain) : 소프트웨어로 해결하고자하는 문제 및 관심사
* 데이터 접근 객체 DAO(data access object)
  * 테이블이나 특정 도메인 객체를 저장하는 데이터 베이스와 상호작용시 사용
  * 영구 저장 데이터 베이스나 인메모리 데이터베이스 같은 데이터 소스로의 접근을 추상화하고 캡슐화 함.
  * 약점 : 필요한 일부 기능을 포함하는 클래스 전체를 디펜던시로 추가 한다는 약점??
* 놀람 최소화 원칙(principle of least surprise) <- 사용해야 무슨일이 일어나는지 명확하게 이해 가능 함.
  * 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명을 사용한다.
  * 코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로 파라미터의 상태를 바꾸지 않는다.
  * 요 원칙은 주관적인 부분이 많아 팀원들과 함께 의논하는 것이 좋다.
