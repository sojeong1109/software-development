## 목차
* SRP (Single Responsibility Principle) 단일책임원칙
* OCP (Open Close Principle) 개방폐쇄원칙
* LSP (Listov Substitution principle) 리스코프 치환 원칙
* ISP (Interface Segregation principle) 인터페이스 분리 원칙
* DIP (Dependency Inversion Principle) 의존 역전 원칙

OOP 4대 특성 : 주방도구
추상화/ 상속/ 캡슐화/ 다형성
OOD (객체 지향 설계) 5원칙 : 주방 도구 설명서
SOLID
DP (디자인 패턴) : 레시피

### SOLID 
* 유지보수와 확작, 변경에 용이하며, 유연해야함.

### SRP single responsibility principle
* 단일 책임 원칙
* 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C.마틴
* 하나의 클래스에 여러개를 의미하는 객체를 만들어서 변경의 소지를 많이 두거나 조건문(if) 를 걸어서 장황한 코드를 짜지 말고
* 클래스와 메소드는 하나의 역할만 하도록 한다.
* 변화의 시기와 이유가 다르면 클래스는 분리하여야 한다.
* ex. 
* 아빠이면서, 남편이면서, 아들이면서 하는 남자가 있다고 치면
* 각 역활별로 하는 행동이 나뉘어져 있다고 하면
* 한개의 클래스 안에 모든것을 정의하지 않고 
* 아빠클래스, 남편클래스, 아들클래스를 역할마다 클래스를 분리.

### OCP open close principle
* 개방 폐쇄 원칙
* 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. - 로버트 C.마틴
* 즉, 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
* ex.
* JDBC 를 보면 데이터베이스가 MySQL에서 오라클로 바뀌더라도 Connection을 설정하는 부분만 변경해주면 됨.
* 자바 어플리케이션은 DB라고 하는 주변의 변화에 닫혀있고, DB를 교체 하는 것은 DB가 자신의 확장에는 열려있는 것.
* -- 잘 와닿지 않음  다른 예제 혹은 설명 봐야함.

### LSP Listov Substitution Principle
* 리스코프 지환 원칙
* 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다. - 로버트 C.마틴
* 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
* 구현 클래스 is able to 인터페이스: 구현 분류는 인터페이스할 수 있어야 한다.
* 이런 경우 Bag 클래스의 행위를 손상하지 않고 일관성 있게 실행하는 클래스를 만들려면 가장 쉬운 방법이 슈퍼 클래스에서 상속 받은 메서드들이 서브 클래스에 재정의되지 않도록 하면 된다.
* https://programmingfbf7290.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%993-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99LSP

### ISP Interface Segregation principle
* 인터페이스 분리 원칙
* 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다. - 로버트 C.마틴
* 결론적으로는 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.
* 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.
* 상위 클래스는 풍성할수록 좋다.
  * 상위클래스가 풍성할 수록 캐스팅(Casting)이 적게 일어나서 소스코드가 깔끔해진다. 때문에 상위클래스가 풍성할 수 록 좋다.
  * 풍성할수록 하위 클래스에게 많은 기능을 확장시켜주는 것이고, 형변환, 코드 중복을 줄여줍니다.
* 인터페이스 내에 메소드는 최소한 일수록 좋다
  * 인터페이스는 하위 클래스에게 구현을 강제하도록 하는 역할입니다. 즉, 최소한의 기능만 제공하면서 하나의 역할에 집중하라는 뜻입니다.
* SRP의 예제 중 남자를 단일 책임을 갖는 클래스로 나누었다.
  * 이것은 너무 많은 클래스 구현을 불러 온다.
  * 그래서 다양한 역할을 인터페이스로 만들고 남자라는 클래스는 그 인터페이스를 구현한 클래스이면 된다.
  * ex. 남자친구 홍길동 = new 남자();

### DIP Dependency Inversion Principle
* 의존 역전 원칙
* 자신보다 변하기 쉬운 것에 의존하지 마라.
* 고차원 모듈(자동차)은 저차원 모듈(타이어브랜드 처럼 자주 바뀌는 것)에 의존하면 안 된다.
* 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.
자주 변경되는 구체(Concrete) 클래스에 의존하지 마라 - 로버트 C.마틴 -
* 자동차가 타이어 브랜드 하나하나에 의존하면 안되고(안되는 이유는 자주 바뀌는것에 의존하면 자동차도 계속 영향을 받게 됨.)
* 타이어 라는 추상화된 타이어 인터페이스에만 의존하게 함으로써 타이어 브랜드가 변경 되어도 자동차가 영향을 받지 않도록 해야함.
* 이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스에 두어 변하기 쉬운 것의 변화에 영향을 받지 않게 하는 것이 '의존 역전 원칙'임
* 상위 클래스일수록, 인터페이스일 수록, 추상클래스일 수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상클래스를 통해 의존하라는 것이 바로 의존역전원칙 임.
* 

### 추상클래스 vs interface
* 추상클래스 = 미완성 설계도.
  * extends
  * abstract를 붙여서 사용 (public abstract class 동물 {} )
  * 선언부는 있는데 구현부가 없는 메소드
  * 추상 클래스는 인스턴스, 즉 객체를 만들 수 없는 클래스 입니다.
  * 추상 메소드는 하위 클래스에서 메소드의 구현을 강제해야 합니다. abstract void 울어보세요();
  * 추상 메소드를 포함하는 클래스는 반드시 추상 클래스여야 합니다.
  * 상속하는 집합간에는 연간관계가 있습니다.
  * 다중 상속이 불가능함.
  * 아래 "객체지향의 상속" 좀 더 살펴보기
* 인터페이스 = 밑그림만 그려져 있는 기본 설계도
  * implements
  * 구현 클래스 is able to 인터페이스 (= 즉, 무엇을 할 수 있는 이라는 표현)
    * Serializable: 직렬화할 수 있는
    * Comparable: 비교할 수 있는
    * Runnable: 실행할 수 있는
  * 인터페이스는 클래스가 무엇을 할 수 있다라고 하는 기능을 구현하도록 강제하는 특징
  * 모든 멤버 변수는 public static final 이어야 하며, 이를 생략할 수 있습니다.
  * 모든 메소드는 public abstract 이어야 하며, 이를 생략할 수 있습니다.
  * Java 8 부터는 static, default method를 사용할 수 있습니다.
  * 다중상속이 가능합니다.
  * 상속하는 집합간에는 연관관계가 존재하지 않을 수 있습니다.
* 상위 클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메소드의 개수가 적을수록 좋다는 결론에 도달할 수 있습니다.
* 인터페이스는 implements 라는 키워드처럼 인터페이스에 정의된 메소드를 각 클래스의 목적에 맞게 기능을 구현하는 느낌이고, 추상 클래스는 extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 느낌

### 객체지향의 상속
* 상속 :  상속은 is kind of 관계 ()
* 펭귄 is kind of 동물 -> 펭귄은 동물의 한 분류다.
* 객체지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미
* 객체지향에서는 상속이란 일반인들이 생각하는 상속이 아닌 확장, 세분화, 슈퍼 클래스 - 서브 클래스 개념
* 상위 클래스 쪽으로 갈수록 추상화 되었다고 하고, 하위 클래스쪽으로 갈수록 구체화 되었다고 말할 수 있습니다.
* 하위 클래스는 상위 클래스다. 라는 말에 대입이 가능해야함
  * 아들은 아버지다 (X)
  * 고래는 포유류이다 (O)
* 객체 지향의 상속은 상위 클래스의 특성을 재사용 하는 것입니다.
* 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것입니다.
* 객체 지향의 상속은 is kind of 관계를 만족해야 합니다.
* 이런 특성을 통해 extends 를 사용한 이유 알 수 있음.


### IoC/DI
* spring의 기반이 되는 설계 개념을 표현한 것.
* 스프링이란 IoC와 AOP를 지원하는 경량의 컨테이너 프레임워크이다
* Inversion Of Control(제어역전 = 대신해줌) / Dependency Injection(의존성주입 = 대신넣어줌)
* https://sehun-kim.github.io/sehun/springbean-lifecycle/

### SRP vs ISP



### 참고
* https://devlog-wjdrbs96.tistory.com/380
* https://sehun-kim.github.io/sehun/solid/
